Strategy: um método maior para diversos objetos.
Muito útil quando temos um conjunto de algoritmos similares e precisamos alternar entre eles em diferentes pedaços da aplicação. 

Chain of Responsibility: construção de cenários - se n der certo em um, vai para outro, e assim por diante. 
Nesse caso, precisamos de uma classe que monte essa corrente na ordem certa.
Ideal quando há uma lista de comandos a serem executados de acordo com um cenário específico e qual outro cenário deve ser validado em seguida, caso o anterior não satisfaça a condição.

Template Method: classe abstrata pai + classes filhas que ganham esse algoritmo e reparam os "buracos" (o que mais falta implementar)
Usado quando há diferentes algoritmos que possuem estruturas parecidas.

Decorator: visa juntar comportamentos separados ou quebrados em classes diferentes. Um está dentro do outro.

State: separação de resposabilidades: ajuda a manter o controle dos estados simples e organizados através de interfaces de estado e classes que levam a implementação da interface. 
Usado quando o controle das possíveis transições são vários e complexos, fazendo com que a implementação seja complexa.

Builder: Uma classe para construir um objeto complexo (que possui diversos atributos ou lógica de criação complexa). 
Há uma separação da complexidade do objeto e a possibilidade de uma implementação de atributos opcionais mais facilmente.

Observer: Interface de ação + classes observadoras. 
Permite que várias ações sejam executadas de forma transparente à classe principal, reduzindo o acoplamento entre as ações.
Traz desacoplamento para as classes: elas dependem apenas da Interface. 
Adicionar novas classes de comportamento não vai fazer o código quebrar.

Esses patterns podem estar juntos em uma mesma aplicação, ou simplesmente não estarem quando não forem úteis.
