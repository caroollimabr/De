Strategy: um método maior para diversos objetos.
Muito útil quando temos um conjunto de algoritmos similares e precisamos alternar entre eles em diferentes pedaços da aplicação. 

Chain of Responsibility: construção de cenários - se n der certo em um, vai para outro, e assim por diante. 
Nesse caso, precisamos de uma classe que monte essa corrente na ordem certa.
Ideal quando há uma lista de comandos a serem executados de acordo com um cenário específico e qual outro cenário deve ser validado em seguida, caso o anterior não satisfaça a condição.

Template Method: classe abstrata pai + classes filhas que ganham esse algoritmo e reparam os "buracos" (o que mais falta implementar)
Usado quando há diferentes algoritmos que possuem estruturas parecidas.

Decorator: visa juntar comportamentos separados ou quebrados em classes diferentes. Um está dentro do outro.

State: separação de resposabilidades: ajuda a manter o controle dos estados simples e organizados através de interfaces de estado e classes que levam a implementação da interface. 
Usado quando o controle das possíveis transições são vários e complexos, fazendo com que a implementação seja complexa.


Esses patterns podem estar juntos em uma mesma aplicação.
